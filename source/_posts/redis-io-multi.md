---
title: 多路复用
date: 2019-10-19 11:18:21
tags: redis
---

# 用户空间和内核空间
学习Linux时，经常可以看到2个次：用户空间和内核空间。
简单来说，内核空间是Linux内核的运行空间，用户空间是用户程序的运行空间。为了安全，他们是隔离的，即使用户的程序崩溃了，他们也不会受影响。
{% asset_img redis-io-multi-1.png %}

# PIO和DMA

+ PIO
我们拿磁盘来说，很早以前，磁盘和内存之间的数据传输是需要CPU控制的，也就是说**如果我们读取磁盘文件到内存中，数据需要经过CPU存储转发，这种方式称为PIO**。显然这种方式非常不合理，需要占用大量的CPU时间来处理文件，造成文件访问时系统几乎停止响应。

+ DMA
后来，**DMA（直接内存访问，Direct Memory Access）取代了PIO，它可以不经过CPU而直接进行磁盘和内存（内核空间）的数据交互**。
在DMA模式下，CPU只需要向DMA控制器下达指令，让DMA控制器来处理数据的传输即可，DMA控制器通过系统总线来传输数据，传送完毕再通知CPU，这样就在很大程度上降低了CPU占用率，大大节省了系统资源，而它的传输速度与PIO的差异其实并不明显，因为这主要取决于慢速设备的连接。

可以肯定的是，PIO模式的计算机现在已经很少见到了。

# 缓存IO和直接IO

+ 缓存IO：数据从磁盘先通过DMA copy到内核空间，再从内核空间通过CPU copy到用户空间
+ 直接IO：数据从磁盘通过DMA直接copy到用户空间


# IO访问方式
+ 磁盘IO
+ 网络IO

# 同步IO和异步IO
同步和异步是这对应用程序和内核的交互而言的。同步指的是用户进程触发IO操作并等待或者轮询的去看IO操作是否就绪。而异步是指用户进程触发IO操作以后便开始做自己的事情，而当IO操作已经完成的时候就会得到IO操作完成的通知。

> 指的是用户空间和内核空间数据交互的方式。
> 同步： 用户空间要的数据，必须等到内核空间给它才做其它的事情。
> 异步： 用户空间要的数据，不需要一直等到内核空间给它，先去做其它事情。内核空间会异步通知用户进程结果，并把数据直接给到用户空间。

# 阻塞IO和非阻塞IO
阻塞模式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入函数会立即返回一个状态值，然后用户进程会循环着去内核空间检查io结果。

> 指的是用户空间和内核空间IO操作的方式
> 阻塞：用户空间通过系统调用(systemcall)和内核空间发生IO操作时，该调用是阻塞的
> 非阻塞：用户空间通过系统调用(systemcall)和内核空间发生IO操作时，该调用是不阻塞的，直接返回的，只是返回时，可能没有数据而已。

# IO设计模式之Reactor和Proactor

## 反应器
反应器（Reactor）设计模式是一种为处理并发服务请求，并将请求提交到一个或多个服务处理程序的事件设计模式。当客户端请求抵达后，服务处理程序使用多路分配策略，由一个非阻塞的线程来接收所有的请求，然后派发这些请求至相关的工作线程进行处理。

Reactor模式主要包含下面几部分：
+ 初始事件分发器(Initialization Dispatcher)：用户管理Event Handler，定义、移除Event Handler等。它还作为Reactor模式的入口Synchronous Demultiplexer的select方法以阻塞等待事件返回，当阻塞等待返回时，根据事件发生的Handler将其分发给对应的Event Hanlder进行处理，即回调Event Handler中的handler_event()方法。

+ 同步（多路）事件分离器(Synchronous Event Demultiplexer)：无限循环等待新事件的到来，一旦发现有新的事件到来，就会通知初始事件分发器去调取特定的事件处理器。

+ 系统处理程序(Handles)：操作系统中的句柄，是对资源在操作系统层面上的一种抽象，它可以是打开的文件、一个连接(socker)、Timer等。由于Reactor模式一般使用在网络编程中，因而这里一般指Socket Handler，即一个网络连接(Connection,java nio中的channel)。这个channel注册到Synchronous Event Demultiplexer中，以监听Handle中发生的事件，对ServerSocketChannel可以是Connect事件，对Socketchannel可以是read、write、clone事件等。

+ 事件处理器(Event Handler)：定义事件处理方法，以供Initialization Dispatcher回调使用。


### 为什么使用Reactor模式？
并发系统经常使用reactor模式代替常用的多线程的处理方式，节省系统的资源，提高系统的吞吐量。例如，在高并发的情况下，既可以使用多线程处理方式，又可以使用reactor处理方式。

**多线程的处理方式**
> 为每个单独到来的请求，专门启动一条线程，这样的话造成系统的开销很大，并且在单核的机器上，多线程并不能提高系统的性能，除非有一些阻塞的情况发生。否则线程切换的开销会使系统处理的速度变慢。

**reactor模式的处理**
> 服务端启动一条单线程，用于轮寻io操作是否就绪，当有就绪的才进行相应的读写操作。这样的话就减少了服务器产生大量的线程，也不会出现线程之间切换产生的内存消耗。


以上两种方式都是基于同步的，多线程的处理是我们传统方式下对高并发的处理方式，reactor模式是现今面对高并发和高性能一种主流的处理方式。

{% asset_img redis-io-multi-2.png %}

{% asset_img redis-io-multi-3.png %}
1. 应用启动，将关注的事件handler注册到refactor(也叫Initialization Dispatcher)中
2. 调用refactor，进入无限事件循环，等待注册的事件到来
3. 事件到来，select返回，refactor将事件分发到之前注册的回调函数中处理


# 五种IO模型

+ 同步阻塞IO：即传统的IO模型
+ 同步非阻塞IO：默认创建Socket都是阻塞的，非阻塞IO要求Socket被设置为NONBLOCK。
+ IO多路复用：即经典的reactor模式，又是也被称为异步阻塞IO，java中的selector和linux中的epoll都是这种模型
+ 异步IO：即经典的proactor设计模式，也被称为异步非阻塞io
+ 信号驱动

未完。。。